.data
dictionaryFileName: .asciiz "dictionary.txt"
string1: .asciiz "a````````"
string2: .asciiz "bytes````"
.align 2
pointerTable: .space 4096
.text

la $a0, dictionaryFileName
jal LoadStringsFromFile
move $s0, $v0

#Allocate a whole bunch of memory for the collection of table entries.
#The collection is too big to fit in the data segment (even if the extern and
#data segments were squished together) without changing the memory settings.
#This seems like too much work on the end user's part so on the heap it goes.
 
li $a0, 604456 		# = 8 bytes * the number of words in the file (75557)
li $v0, 9		#syscall 9 allocates memory
syscall			#...
subi $v0, $v0, 8 	#the pointer is incremented by 8 BEFORE it it used each time, so decrement it before its first use
move $s1, $v0


#Start reading strings off the stack and putting them in the hash table.
#################################################################################
#################################################################################

stringReadLoop:

lw $a0, ($sp) 		#$a0: pointer to a string being processed.
addiu $sp, $sp, 4 	#Stack pointer must be manually manipulated... 
beqz $a0, SRLDone 	#The last entry on the stack generated by LoadStringsFromFile was a word filled with zeroes.
			#On encountering this word, string processing is done ->

li $v0, 4		#Print the string being processed.		
syscall			#...

jal HashFunc		#Hash the string in $a0. 
			#The hash value is stored in $v0.
			
move $t7, $v0		#The next few lines print the hash value and a newline,
move $t6, $a0		#requiring a lot of registers to be moved around.
move $a0, $t7		#Taking them all out at once won't hurt anything.
li $v0, 1
syscall
li $a0, 10
li $v0, 11
syscall
move $a0, $t6
move $v0, $t7		#...done.


addiu $s1, $s1, 8	#Move to the next table entry in the collection.
move $t2, $s1

#At this point, $t2 contains the address of the 8-byte
#structure that will hold the address of the string and the address
#of the next link in the chain.
#$a0 contains a pointer to the string we are adding, and $v0 contains the
#hash of that string.

sw $a0, ($t2)
sll $v0, $v0, 2
la $v1, pointerTable
addu $v0,$v0,$v1
lw $t0, ($v0)
bnez $t0, SRLBucketOccupied

sw $t2, ($v0)
b stringReadLoop


SRLBucketOccupied: 	#There was already an entry in the hash table at pointerTable($v0)!
lw $t1, 4($t0) 		#Check the address field of the entry in the hash table
bnez $t1, SRLBOMoveDownChain #If there's an address there, keep going ->
sw $t2, 4($t0) 		#Otherwise, put the new entry into the address field of the current entry.
b stringReadLoop 	#Done -->
SRLBOMoveDownChain:
move $t0, $t1 		#Make the entry in the address field the current entry.
b SRLBucketOccupied 	#Its address field will be checked, etc. ->

SRLDone:
#################################################################################
#################################################################################

la $a0, string1
jal CheckInHashTable
move $a0, $v0
li $v0, 1
syscall

la $a0, string2
jal CheckInHashTable
move $a0, $v0
li $v0, 1
syscall

b quitProgram


######################
# CheckInHashTable: is string in hash table?
# $a0: string
# $v0: 0 if string is in hash table, 1 otherwise
#####################
CheckInHashTable:
move $t7, $ra
jal HashFunc
move $ra, $t7
sll $v0, $v0, 2
lw $t0, pointerTable($v0)
beqz $t0, CIHTFail #no entry in the pointer table for hash($a0): a0 is not in table ->
CIHTLoop:
lw $a1, ($t0)
move $t7, $ra
move $t6, $t0
jal StringCmp
move $t0, $t6
move $ra, $t7
beqz $v0, CIHTSuccess
lw $t1, 4($t0)
beqz $t1, CIHTFail
move $t0, $t1
b CIHTLoop
CIHTSuccess:
li $v0, 0
jr $ra
CIHTFail:
li $v0, 1
jr $ra

####################################################
# StringCmp: compares two 9-character strings.
# Arguments:
#	$a0, a1:	pointers to strings (ASCII, exactly 9 characters)
# Uses registers:
#	$t0-$t4, $v0
# Returns:
#	$v0: 0 if the strings are equal.
#            1 otherwise.
#################################################### 
StringCmp:
li $t4, 9
li $v0, 1
move $t0, $a0
move $t1, $a1
SCLoop:
lb $t2, ($t0)
lb $t3, ($t1)
bne $t2, $t3, SCLoopEnd
subi $t4, $t4, 1
beqz $t4, SCLoopEndSuccess
addi $t0, $t0, 1
addi $t1, $t1, 1
b SCLoop
SCLoopEndSuccess:
li $v0, 0
SCLoopEnd:
jr $ra
######################

quitProgram:
#quit
li $v0, 10
syscall

####################################################
# HashFunc: given 9-character string, produces
# a value corresponding to that string
# between 0 and 1023.
# Arguments:
#	$a0:	pointer to string (ASCII, exactly 9 characters)
# Uses registers:
#	$t0-$t3, $v0
# Returns:
#	$v0: hash
#################################################### 
HashFunc:
li $v0, 0
li $t2, 0
li $t3, 9
move $t0, $a0
HFloop:
addi $t2, $t2, 1
lb $t1, ($t0)
subi $t3, $t3, 1
beqz $t3, HFend
subu $t1, $t1, 96 #converts ASCII char to 0 = '`', 1 = 'a', ...
mulu $t1, $t1, $t2
addu $v0, $v0, $t1
addi $t0, $t0, 1
j HFloop
HFend:
li $t2, 1024
divu $v0, $t2
mfhi $v0
jr $ra 

.include "fileio.asm"

.eqv WORDS_IN_REGULAR_DICT 74563
.eqv WORDS_IN_NINECHAR_DICT 16692
.eqv LOADING_BAR_UPDATE_FREQ 1500 #1 period printed per X words processed at the "Loading" screen
.eqv COMMAND_SIGIL 33 #ASCII 33 is "!"

.macro push (%reg)
subi $sp, $sp, 4
sw %reg, ($sp)
.end_macro

.macro pop (%reg)
lw %reg, ($sp)
addi $sp, $sp, 4
.end_macro



.data

dictionaryFileName: .asciiz "hashtable.dat"
startingWordsDictionaryFileName: .asciiz "ninechar.txt"
.align 2
pointerTable: .space 4096
.align 2
nineCharArray: .space 8
userInputBuffer: .space 10
.align 2
bitArray: .space 9
.align 2
addressFirstElement: .space 4
numWordsInHashtable: .space 4
pointerTableSize: .space 4

loadMsg: .asciiz "Loading"
boxTopBar: .asciiz " /-------------\\\n"
boxBottomBar: .asciiz " \\-------------/\n\n"
boxLeftBar: .asciiz " |  "
boxSeperator: .asciiz "   "
boxRightBar: .asciiz "  |\n"
.align 2
pointerToTestPuzzle: .space 5

#data for command function
quit:	.asciiz	"qhrst"
help:	.asciiz "Commands:\n!q - Quit game\n!t - Display current time\n!e - End game\n!s - Shuffle game board\n!h - Display help\n"
out:	.asciiz	"The command was not found.  Type !help for the list of commands\n"
timemessage1:	.asciiz	"You have "
timemessage2:	.asciiz	" seconds remaining. Current Score: "
newline:	.asciiz "\n"
timeleft:	.word	120	#start with 2 mins?
outoftimemsg:	.asciiz "Out of Time Last entry was not counted!\n"

score:		.word	0	#holds the players score
points1:	.asciiz	"eEiImMoOpPrRsStT"	#these are used in calculating score
points2:	.asciiz	"aAbBcCdDfFlLnN"
points3:	.asciiz	"gGhHjJkKuUvVwWyY"
points4:	.asciiz	"qQxXzZ"


#data for splash screen
splashscreenfilename: .asciiz "SplashScreen.txt"  #current size < 300 chars

#data for pressanykeytocontinue
backspace: .asciiz "\b \n"

.text

# Set up the hash table and the array of
# nine-character words.
####################################################

la $a0, dictionaryFileName
jal LoadHashTable

#Words with nine characters are a special case: they are used to generate a puzzle.
#Thus, they are kept in their own file, and loaded into a simple array rather than the hashtable.
la $a0, startingWordsDictionaryFileName
jal LoadStringsFromFile
li $a0, WORDS_IN_NINECHAR_DICT
sll $a0, $a0, 2		#4 bytes per pointer * the number of 9-character words (16692)
li $v0, 9
syscall
move $t0, $v0		#Since we'll be incrementing $v0 as we add words, we need to save a pointer
			#to the beginning of the array.
nineCharStringReadLoop:
lw $a0, ($sp) 		#$a0: pointer to a string being processed.
addiu $sp, $sp, 4 	#Stack pointer must be manually manipulated... 
beqz $a0, NCSRLDone 	#The last entry on the stack generated by LoadStringsFromFile was a word filled with zeroes.
			#On encountering this word, string processing is done ->
sw $a0, ($v0)		#Put the string into the current position in the array.
addiu $v0, $v0, 4	#Increment the current position of the array.
b nineCharStringReadLoop
NCSRLDone:
la $v1, nineCharArray
sw $t0, ($v1)
####################################################
# The hashtable and array are loaded: the game can start.
startgame:
jal PrintSplashScreen

newRound:
jal GenPuzzle
move $s1, $v0
move $s2, $zero
jal SetTime

gameInputLoop:
jal PrintPuzzle	#Print the current puzzle...
li $v0, 8
li $a1, 10
la $a0, userInputBuffer
syscall		#Then, poll user for input.
lb $t0, ($a0)	#Check the first letter of the user's input.
beq $t0, COMMAND_SIGIL, handleCommand	#If it is the command sigil, process the input as a command.
jal CheckWord	#Otherwise, it is a word.
move $t4, $v0	#move returned value from CheckWord into $t4 and $a0
move $a0, $v0
li $v0, 1
syscall
li $a0, 10
li $v0, 11
syscall
jal CheckTime
bnez $t4, noPoints
lw $t0 timeleft		#fetch timeleft from last caculated 
add $t0,$t0,20		#add 20 seconds to the clock
sw $t0, timeleft	#save it as the new timeleft
## to do make a String checker to look through the input and assign a certain score for each letter.
jal ScoreCheck
lw $t0,score
add $t0,$t0,$v1
sw $t0,score
noPoints:

b gameInputLoop


####################################################
# CheckWord: given user's input, check whether:
#	1. All of the characters are in the puzzle, with no duplicates allowed
#	2. The middle character in the puzzle was used
#	3. The input is a valid word
# Arguments:
#	$a0: user input
#	$s1: puzzle
# Uses registers:
#	nearly all of them
# Returns:
#	$v0 is a status code:
#		0: word satisfied all conditions
#		1: word was not in hashtable
#		2: word did not have the middle letter
#		3: word had characters other than those in the puzzle
####################################################
CheckWord:
sw $zero, bitArray	#bitArray has to be cleaned up from the last time it was called.
sw $zero, bitArray+4	#...
sb $zero, bitArray+8	#...done. (4+4+1 = 9 bytes of space)
li $t4, 1		#$t4 holds the value 1, solely for the purpose of storing it in bitArray[n].
move $t5, $a0		#preserve $a0 in $t5; $a0 is manipulated in CWCheckLettersLoop
lw $a1, ($s1)		#$a1: pointer to the puzzle string! (don't forget: $s1 is a pointer to a pointer!)

#This loop iterates over the characters in the user's input until it reaches
#a newline or null. (Only strings of nine characters have no newline character.)
#An interior loop, CWFindLetterInPuzzle, iterates FORWARD through the puzzle string
#while counting BACKWARD from 8 to 0; if the character from the input matches a character
#in the puzzle string, a 1 is written to bitArray[counter]. Note, therefore, that
#the order of bitArray is the opposite of the puzzle string; note, too, that this does not matter,
#because only the middle element is of interest after this loop and this would be bitArray[4] in either case.

CWCheckLettersLoop:
lb $t0, ($a0)
beqz $t0, CWLoopSuccess #null byte signals the end of a string
beq $t0, 10, CWLoopSuccess #so does a newline
li $t1, 9
lw $a1, ($s1)

CWFindLetterInPuzzle:
subi $t1, $t1, 1	#Loop runs from 8 down to 0.
bltz $t1, CWFailLetterNotInPuzzle
lb $t2, ($a1)
addiu $a1, $a1, 1
beq $t0, $t2, CWFLIPDone
b CWFindLetterInPuzzle
CWFLIPDone:

lb $t3, bitArray($t1)
bnez $t3, CWFindLetterInPuzzle
sb $t4, bitArray($t1)
addiu $a0, $a0, 1
b CWCheckLettersLoop

CWLoopSuccess:

lb $t1, bitArray+4
ble $t1, $zero, CWFailNoMidLetter

#We are finally ready for the last test: putting the word through the hash table.
#Before we can do this, however, we must pad the word with `s until it is nine
#characters long, unless, of course, it is already nine characters long.
#The good news is that CWCheckLettersLoop has done a lot of heavy lifting for us:
#	$t0 is a newline (if word is less than 9 chars), zero otherwise;
#	$a0 points to that newline or null character;
#	and $t5 points to the beginning of the user input.
#Therefore, the length of the input is simply $a0 - $t5!

li $t4, '`'
beqz $t0, CWFormatInputDone
sub $t0, $a0, $t5
li $t1, 9
sub $t0, $t1, $t0 #now $t0 is the number of `s we need
CWFIInsertPadding:
sb $t4, ($a0)
addi $a0, $a0, 1
subi $t0, $t0, 1
beqz $t0, CWFormatInputDone
b CWFIInsertPadding

CWFormatInputDone:

move $a0, $t5
push ($ra)
jal CheckInHashTable
pop ($ra)
jr $ra

CWFailNotWord:
	#CheckInHashTable returns 1 in $v0 if input is not in the table.

CWFailNoMidLetter:
li $v0, 2
jr $ra

CWFailLetterNotInPuzzle:
li $v0, 3
jr $ra

####################################################
# handleCommand: handles the command in $a0.
# Supported commands:
#	none yet
# Note: this is not a function. Don't use "jal handleCommand",
# use "b handleCommand" instead.
####################################################

handleCommand:
li $t4, 0
lb $t0, 1($a0)
la $t1, quit
CheckCommandList:
lb $t2, ($t1)
beqz $t2, notfound
beq $t0, $t2, found
add $t1, $t1, 1
add $t4, $t4, 1
j CheckCommandList
found:
bgt $t4, 0, gzero	
j quitProgram		#quit
gzero:
bgt $t4, 1, gone	
li $v0, 4		#help
la $a0, help
syscall
j HCCommandDone
gone:
bgt $t4, 2, gtwo
j startgame		#restart
gtwo:
bgt $t4, 3, gthree
lw $v1, ($s1)		#shuffle
lb $t4, 4($v1)		#holds the middle char before shuffle
push ($t4)
push ($t0)
li $t0, 8
addu $v1, $v1, $t0
move $t1, $s1
jal GPShuffleLoop
pop ($t4)
li $t1, 0
lb $t5, 4($v1)		#holds the current middle char
beq $t4, $t5, midCharCorrect	#checks to see if it is holding the correct char
findPastMidLoop:		#find the location of the middle char
lb $t0, ($v1)
beq $t4, $t0, midLocated
add $v1, $v1, 1
add $t1, $t1, 1
j findPastMidLoop
midLocated:
sb $t5, ($v1)			#put the wrong mid char in the place where the true mid is
sub $v1, $v1, $t1		#return to pointing to the beginning
sb $t4, 4($v1)			#store true mid at the mid
midCharCorrect:
j HCCommandDone			#print puzzle and continue
gthree:
bgt $t4, 4, gfour
jal printTime
j HCCommandDone
gfour:
notfound:
li $v0, 4
la $a0, out
syscall
HCCommandDone:
j gameInputLoop


######################################################

teststringgen:	#Temporary loop for testing the puzzle generator.
li $t0, 5	#Generates this many random scrambled 9-char words, prints them, quits.
tsgloop:
beqz $t0, quitProgram
jal GenPuzzle
lw $a0, ($v0)
li $v0, 4
syscall
li $a0, 10
li $v0, 11
syscall
subi $t0, $t0, 1
b tsgloop

testreadloop:	#Temporary loop for testing the hashtable
li $v0, 8
li $a1, 10
la $a0, userInputBuffer
syscall
jal CheckInHashTable
move $a0, $v0
li $v0, 1
syscall
li $a0, 10
li $v0, 11
syscall
b testreadloop


####################################################
# PrintPuzzle: prints a textual representation of
# the current puzzle. For example, if the puzzle
# is "123456789", 
# /-------------\
# |  1   2   3  |
# |  4   5   6  |
# |  7   8   9  |
# \-------------/
# will be printed to the console.
# The appearance of the box can be changed without too much, if any, changes
# made to this function, since the parts of the box are stored in strings like
# boxTopBar, boxSeperator, etc. What this function actually prints to the screen is:
# [TB]
# [LB]1[S]2[S]3[RB] (3 times)
# [BB]
# Note: this function does not print newlines. They must be included in [TB], [RB], etc.
# Arguments:
#	$s1: pointer to the puzzle (a nine-char string)
# Uses registers:
#	$a0-1, $v0, $t0
# Returns:
#	nothing
####################################################
PrintPuzzle:
push ($ra)
lw $a1, ($s1)
la $a0, boxTopBar
li $v0, 4
syscall
li $t0, 3
PPBoxLoop:
subiu $t0, $t0, 1
la $a0, boxLeftBar
syscall
jal PPNextChar
la $a0, boxSeperator
li $v0, 4
syscall
jal PPNextChar
la $a0, boxSeperator
li $v0, 4
syscall
jal PPNextChar
la $a0, boxRightBar
li $v0, 4
syscall
bnez $t0, PPBoxLoop
la $a0, boxBottomBar
li $v0, 4
syscall
jal printTime
pop ($ra)
jr $ra
PPNextChar:
lb $a0, ($a1)
li $v0, 11
addiu $a1, $a1, 1
syscall
jr $ra

####################################################
# ScoreCheck: takes the word and caulates a score based on the word
# this is a function so call using jal
# Arguments:
#	userInputBuffer (the string the user has typed in)
# Uses registers:
#	$t0-3
# Returns:
#	$v1 (amount of points earned for this word)
####################################################
ScoreCheck:	#gg ScoreCheck intials are SC just like StringCompare, so it errored at first time cause SCLoop was defined twice
push($ra)
move $v1,$zero
move $t3,$zero
SCKLoop:
	lb $t1,userInputBuffer($t3)	#load character at $a2
	add $t3,$t3,1
	beq $t1,$zero SCKDone
	beq $t1,10 SCKDone
	move $t0,$zero
	SCKP1L:
		lb $t2, points1($t0)
		beq $t2,$zero SCKP1LD
		beq $t2,10 SCKP1LD
		add $t0,$t0,1	
		bne $t1,$t2 SCKP1L
		add $v1,$v1,1
		b SCKLoop
	SCKP1LD:
	move $t0,$zero
	SCKP2L:
		lb $t2, points2($t0)
		beq $t2,$zero SCKP2LD
		beq $t2,10 SCKP2LD
		add $t0,$t0,1	
		bne $t1,$t2 SCKP2L
		add $v1,$v1,2
		b SCKLoop
	SCKP2LD:
	move $t0,$zero
	SCKP3L:
		lb $t2, points3($t0)
		beq $t2,$zero SCKP3LD
		beq $t2,10 SCKP3LD
		add $t0,$t0,1	
		bne $t1,$t2 SCKP3L
		add $v1,$v1,3
		b SCKLoop	
	SCKP3LD:
	move $t0,$zero	
	SCKP4L:
		lb $t2, points4($t0)
		beq $t2,$zero SCKLoop
		beq $t2,10 SCKLoop
		add $t0,$t0,1	
		bne $t1,$t2 SCKP4L
		add $v1,$v1,4
		b SCKLoop			
SCKDone:	
pop($ra)
jr $ra
		





####################################################
# printTime: displays the time remaining and his/her score to the client
# this is a function so call using jal
# Arguments:
#	none
# Uses registers:
#	$s2 (holds the time from last calculated), $t0, $a0, $v0
# Returns:
#	nothing
####################################################
printTime:
push ($ra)
push ($a0)	#preserve these registars
push ($a1)

jal CheckTime	#check and updates time left

blez $v1, GameFinished	#if out of time your done

la $a0, timemessage1	#print Time left sentence
li $v0, 4
syscall

la $a0, ($v1)
li $v0, 1
syscall

la $a0, timemessage2
li $v0, 4
syscall

lw $t0,score
la $a0, ($t0)
li $v0, 1
syscall

la $a0, newline
li $v0, 4
syscall

pop ($a1)	#give back
pop ($a0)
pop ($ra)
jr $ra


####################################################
# CheckTime: check if user still has time left
# Will branch to GameFinished if time left is negative or zero
# this is a function so call using jal
# Arguments:
#	none
# Uses registers:
#	$s2 (holds the time from last calculated), $t0, $a0, $v0
# Returns:
#	timeleft in $v1
####################################################
CheckTime:
move $t0,$s2		#move time from last check into t0
li $v0, 30		#get time
syscall
move $s2,$a0		#move caculated time into $s2
sub $a0,$a0,$t0		#subtract current time from previous time to get the difference
div $a0,$a0,1000	#convert milliseconds to seconds, if faster way feel free to change it
lw $t0 timeleft		#fetch timeleft from last caculated 
sub $t0,$t0,$a0		#subtract the difference from the timeleft
sw $t0, timeleft	#save it as the new timeleft
move $v1,$t0		#move timeleft into $v1
jr $ra			

####################################################
# SetTime: resets timer to 120 seconds and sets $s2 to current time
# this is a function so call using jal
# Arguments:
#	none
# Uses registers:
#	$s2, $a0, $v0
# Returns:
#	nothing
####################################################
SetTime:
push ($a0)		#preserve these registars, incase used else where
push ($a1)
li $v0, 30		#syscall 30 is fetch Time
syscall
move $s2,$a0
add $a0,$zero,120	#put 120 seconds on the clock
sw $a0 timeleft		#store the time in the timeleft label
pop ($a1)		#give back values of a0 and a1
pop ($a0)
jr $ra


####################################################
# GenPuzzle: picks a random entry in the array of nine-character words;
# then, scrambles the string, and returns a pointer to it.
# Arguments:
#	none
# Uses registers:
#	$a0, $a1, $v0
# Returns:
#	$v0: a pointer to the string
####################################################
GenPuzzle:
push ($t0)
li $v0, 30	#syscall 30 gets system time as a 64-bit int.
syscall 	#It is placed in $a0 and $a1;
li $v0, 42 	#42 gets a random number in a range,
move $a0, $a1
li $a1, WORDS_IN_NINECHAR_DICT #where $a1 is the upper bound (lower bd. is 0)
subiu $a1, $a1, 1
syscall 		#and $a0 is a random seed!
sll $a0, $a0, 2
la $v1, nineCharArray
lw $v1, ($v1)
addu $a0, $a0, $v1	#a0 points to the random string.
#Now, we will scramble the string.
#NOTE: the string is NOT copied before it is scrambled.
#The original is being scrambled, and this is OK iff (since)
#nothing special happens when the user finds the puzzle's seed.
move $t1, $a0
lw $v1, ($a0)		#$v1 points to the first character of the string
li $t0, 8
addu $v1, $v1, $t0	#now it points to the last character of the string
GPShuffleLoop:
beqz $t0, GPEnd
li $v0, 42 		#Generate random int...
move $a1, $t0		#between 0 and the loop counter.
move $a0, $t1
syscall			#Note: the pointer to the string is used as a random seed
addiu $a0, $a0, 1
subu $v0, $v1, $a0	#$v0 points to a random character in the string
lb $t2, ($v1)
lb $t3, ($v0)
sb $t3, ($v1)
sb $t2, ($v0)
subiu $t0, $t0, 1
subiu $v1, $v1, 1
b GPShuffleLoop
GPEnd:
move $v0, $t1
pop ($t0)
jr $ra


####################################################
# PressKeyToContinue: Pauses program until an alphanumaric key is pressed
# 
# Arguments:
#	none
# Uses registers:
#	$v0
# Returns:
#	Nothing
####################################################
PressKeyToContinue:
li $v0 12
syscall		# "Pauses" by trying to read a char from the keyboard

li $v0, 4
la $a0, backspace
syscall		# Removes typed char  (Doesn't right now, any ideas how to fix this?)

jr $ra

####################################################
# PrintSplashScreen: Prints out the splah screen and calls PressKeyToContinue
# 
# Arguments:
#	none
# Uses registers:
#	$v0, $a0, $a1, $a2, $t0, $t1
# Returns:
#	Nothing
####################################################
PrintSplashScreen:
li $v0, 13
la $a0, splashscreenfilename
li $a1, 0
syscall			# Open the SplashScreen file
move $t0, $v0		# Save file descriptor

li $v0, 9
li $a0, 300
syscall			# Allocate space on the heap to print from
move $t1, $v0		# Save pointer to heap space

li $v0, 14
move $a0, $t0
move $a1, $t1
li $a2, 300
syscall			# Read up to 250 chars from file into heap

li $v0, 16
move $a0, $t0
syscall			# Close SplashScreen file

li $v0, 4
move $a0, $t1
syscall			# Print file from heap

push ($ra)

jal PressKeyToContinue

pop ($ra)
jr $ra


GameFinished:
## to do make a Game ending screen thingy
la $a0, outoftimemsg	#prints that your last guess was not counted cause out of time
li $v0, 4
syscall

jal PressKeyToContinue	# allow time to view the ending screen

b quitProgram		#possible replace this with a branch to New Round

quitProgram: #quit
li $v0, 10
syscall

.include "hashtable.asm"

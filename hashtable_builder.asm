.eqv HASH_TABLE_NUM_WORDS 74563
.eqv HASH_TABLE_NUM_WORDS_PLUS_ONE 74564
.eqv POINTER_TABLE_SIZE_BYTES 4096

.data
dictionaryFileName: .asciiz "dictionary.txt"
hashtableFileName: .asciiz "hashtable.dat"
loadMsg: .asciiz "Building hash table."
.align 2
userInputBuffer: .space 10
.align 2
tempWord: .space 4
addressFirstElement:
pointerTableSize:
numWordsInHashtable:
.text


li $a0, HASH_TABLE_NUM_WORDS
li $a1, 18
mul $a0, $a0, $a1
addiu $a0, $a0, POINTER_TABLE_SIZE_BYTES
move $s0, $a0


####################################################
# First, load 
# the dictionary file onto the heap.
# Arguments:
#	$a0:	pointer to filename (ASCII, 0-terminated)
# Uses registers:
#	$t0, $a and $v registers
# Returns:
#	$v0:	pointer to the strings
#################################################### 
li $v0, 13
la $a0, dictionaryFileName
li $a1, 0 	#read from file
li $a2, 0 	#open file mode: ignored
syscall
move $t0, $v0	#we need the file reference to read from the file later

####################################################
# The hash table is made up of three parts:
#	1. The pointer table (size: 4096 bytes)
#	2. The table entry collection (size: 8 bytes * number of words)
#	3. The word collection (size: 10 bytes * number of words)
#
# The table is stored contiguously in memory, with the three components side by side.
# Enough memory for the entire hashtable is allocated all at once, and then offsets to each
# component are calculated and stored in the $s registers:
#	$s0 will point to the pointer table.
#	$s1 will point to the table entry collection.
#	$s2 will point to the word collection.
#################################################### 

move $a0, $s0
li $v0, 9 
syscall

#Calculate offsets...

move $s0, $v0
addi $s1, $s0, POINTER_TABLE_SIZE_BYTES
li $a0, HASH_TABLE_NUM_WORDS
li $a1, 8
mul $a0, $a0, $a1
add $s2, $s1, $a0

li $a0, HASH_TABLE_NUM_WORDS
li $t1, 10
mul $t1, $t1, $a0

move $a1, $s2	#Read from the file...
move $a0, $t0	#(file reference is in $t0)
move $a2, $t1	#(size in bytes of word collection is in $t1)
li $v0, 14
syscall

move $a0, $t0
li $v0, 16 #close file
syscall

####################################################
# BuildHashTable: creates the main hash table.
# Strings on the stack (pointed to by $sp)
# are read, one by one, and hashed using HashFunc.
# Then, a pointer to the current string is placed 
# in the first half of an 8-byte structure.
# If the bucket at pointerTable[hash(string)] is populated, 
# place the pointer to the new structure in the second half
# of the structure in the pointer table. Otherwise, place the pointer
# to the structure in the pointer table.
#####
# Effectively, therefore, the hashtable is an array of singly-linked lists.
# As currently implemented, there are 1024 "buckets" in the pointer table;
# with a dictionary of about 75,000 elements, the worst-case performance
# involves traversing a singly-linked list of (75000/1024) = about 75 iterations.
# This is technically O(n), but, in practice, performance is adequate for the application.
#####
# Arguments:
#	$sp:	last element in an array of pointers to nine-character strings, whose first element is the null pointer
#	$a0:	the number of words to insert into the hash table
# Uses registers:
#	$t0-$t7 NOT $t5, $v0, $v1, $s1, $a0, $a1
# Returns:
#	nothing
#################################################### 
BuildHashTable:
#Allocate a whole bunch of memory for the collection of table entries.
#The collection is too big to fit in the data segment (even if the extern and
#data segments were squished together) without changing the memory settings.
#This seems like too much work on the end user's part so on the heap it goes.
 
subi $s1, $s1, 8 	#the pointer is incremented by 8 BEFORE it it used each time, so decrement it before its first use

la $a0, loadMsg		#Print the loading message.
li $v0, 4
syscall

li $t4, 0		#$t4 will be a counter. Every now and then
move $t5, $s2		#$t5 will point to word collection and be incremented in a loop
#Start reading strings and putting them in the hash table.
stringReadLoop:
addi $t4, $t4, 1
move $a0, $t5 		#$a0: pointer to a string being processed.
addiu $t5, $t5, 10 	# 
beq $t4, HASH_TABLE_NUM_WORDS_PLUS_ONE, SRLDone 	#The last entry on the stack generated by LoadStringsFromFile was a word filled with zeroes.
			#On encountering this word, string processing is done ->

jal HashFunc		#Hash the string in $a0. 
			#The hash value is stored in $v0.

li $t7, 1000 		#Print the "loading bar":
div $t4, $t7		#a period once every L_B_U_F words.
move $t7, $v0		#$a0 and $v0 have to be moved around.
move $t6, $a0		
mfhi $v0
bnez $v0, SRLDontPrintAnything
li $a0, '.'
li $v0, 11
syscall
SRLDontPrintAnything:
move $a0, $t6
move $v0, $t7		#...done with loading bar.

#move $t7, $v0		#The next few lines print the string, its hash, and a newline, useful for debugging.
#li $v0, 4		#If you want to turn this on, be sure to comment out the loading bar stuff.	
#syscall		
#move $t6, $a0		
#move $a0, $t7		
#li $v0, 1
#syscall
#li $a0, 10
#li $v0, 11
#syscall
#move $a0, $t6
#move $v0, $t7		#...done with diagnostic stuff.

addiu $s1, $s1, 8	#Move to the next table entry in the collection.
move $t2, $s1

#At this point, $t2 contains the address of the 8-byte
#structure that will hold the address of the string and the address
#of the next link in the chain.
#$a0 contains a pointer to the string we are adding, and $v0 contains the
#hash of that string.

sw $a0, ($t2)
sll $v0, $v0, 2
move $v1, $s0
addu $v0, $v0, $v1
lw $t0, ($v0)
bnez $t0, SRLBucketOccupied

sw $t2, ($v0)
b stringReadLoop


SRLBucketOccupied: 	#There was already an entry in the hash table at pointerTable($v0)!
lw $t1, 4($t0) 		#Check the address field of the entry in the hash table
bnez $t1, SRLBOMoveDownChain #If there's an address there, keep going ->
sw $t2, 4($t0) 		#Otherwise, put the new entry into the address field of the current entry.
b stringReadLoop 	#Done -->
SRLBOMoveDownChain:
move $t0, $t1 		#Make the entry in the address field the current entry.
b SRLBucketOccupied 	#Its address field will be checked, etc. ->

SRLDone:
li $a0, '\n'
li $v0, 11
syscall

#The hashtable has been created!

li $v0, 13
la $a0, hashtableFileName
li $a1, 1 	#write-only to file (creates file if it doesn't exist)
li $a2, 0 	#open file mode: ignored
syscall
move $t0, $v0	#we need the file reference to write to the file later

#The first 4 bytes of hashtable.dat are the address of the hashtable.
#This will be used by Lexathon for calculating pointer offsets.

sw $s0, tempWord
move $a0, $t0
la $a1, tempWord
li $a2, 4
li $v0, 15
syscall

#The next 8 bytes are:
#	1. Number of words in the hashtable (4 bytes)
#	2. Size of pointer table (4 bytes)

move $a0, $t0
li $a1, HASH_TABLE_NUM_WORDS
sw $a1, tempWord
la $a1, tempWord
li $a2, 4
li $v0, 15
syscall

move $a0, $t0
li $a1, POINTER_TABLE_SIZE_BYTES
sw $a1, tempWord
la $a1, tempWord
li $a2, 4
li $v0, 15
syscall

#Finally, the hash table is dumped into the file.

move $a0, $t0
li $a2, HASH_TABLE_NUM_WORDS
li $a1, 18
mul $a2, $a2, $a1
addiu $a2, $a2, POINTER_TABLE_SIZE_BYTES
move $a1, $s0
li $v0, 15
syscall

#And then the file is closed.

move $a0, $t0
li $v0, 16
syscall

b quitProgram #Comment this line out to test the hashtable

##################################################################################

testreadloop:	#Temporary loop for testing the hashtable
li $v0, 8
li $a1, 10
la $a0, userInputBuffer
syscall
jal CheckInHashTable
move $a0, $v0
li $v0, 1
syscall
li $a0, 10
li $v0, 11
syscall
b testreadloop

#################################################################################

quitProgram:
li $v0, 10
syscall

.include "hashtable.asm"
####################################################
# BuildHashTable: creates the main hash table.
# Strings on the stack (pointed to by $sp)
# are read, one by one, and hashed using HashFunc.
# Then, a pointer to the current string is placed 
# in the first half of an 8-byte structure.
# If the bucket at pointerTable[hash(string)] is populated, 
# place the pointer to the new structure in the second half
# of the structure in the pointer table. Otherwise, place the pointer
# to the structure in the pointer table.
#####
# Effectively, therefore, the hashtable is an array of singly-linked lists.
# As currently implemented, there are 1024 "buckets" in the pointer table;
# with a dictionary of about 75,000 elements, the worst-case performance
# involves traversing a singly-linked list of (75000/1024) = about 75 iterations.
# This is technically O(n), but, in practice, performance is adequate for the application.
#####
# Arguments:
#	$sp:	last element in an array of pointers to nine-character strings, whose first element is the null pointer
#	$a0:	the number of words to insert into the hash table
# Uses registers:
#	$t0-$t7, $v0, $v1, $s1, $a0, $a1
# Returns:
#	nothing
#################################################### 
BuildHashTable:
move $t5, $ra
#Allocate a whole bunch of memory for the collection of table entries.
#The collection is too big to fit in the data segment (even if the extern and
#data segments were squished together) without changing the memory settings.
#This seems like too much work on the end user's part so on the heap it goes.
 
sll $a0, $a0, 3 	# = 8 bytes * the number of words in the file
li $v0, 9		#syscall 9 allocates memory
syscall			#...
subi $v0, $v0, 8 	#the pointer is incremented by 8 BEFORE it it used each time, so decrement it before its first use
move $s1, $v0

la $a0, loadMsg		#Print the loading message.
li $v0, 4
syscall

li $t4, 0		#$t4 will be a counter. Every now and then

#Start reading strings off the stack and putting them in the hash table.
stringReadLoop:
addi $t4, $t4, 1
lw $a0, ($sp) 		#$a0: pointer to a string being processed.
addiu $sp, $sp, 4 	#Stack pointer must be manually manipulated... 
beqz $a0, SRLDone 	#The last entry on the stack generated by LoadStringsFromFile was a word filled with zeroes.
			#On encountering this word, string processing is done ->

jal HashFunc		#Hash the string in $a0. 
			#The hash value is stored in $v0.

li $t7, LOADING_BAR_UPDATE_FREQ #Print the "loading bar":
div $t4, $t7		#a period once every L_B_U_F words.
move $t7, $v0		#$a0 and $v0 have to be moved around.
move $t6, $a0		
mfhi $v0
bnez $v0, SRLDontPrintAnything
li $a0, '.'
li $v0, 11
syscall
SRLDontPrintAnything:
move $a0, $t6
move $v0, $t7		#...done with loading bar.

#move $t7, $v0		#The next few lines print the string, its hash, and a newline, useful for debugging.
#li $v0, 4		#If you want to turn this on, be sure to comment out the loading bar stuff.	
#syscall		
#move $t6, $a0		
#move $a0, $t7		
#li $v0, 1
#syscall
#li $a0, 10
#li $v0, 11
#syscall
#move $a0, $t6
#move $v0, $t7		#...done with diagnostic stuff.

addiu $s1, $s1, 8	#Move to the next table entry in the collection.
move $t2, $s1

#At this point, $t2 contains the address of the 8-byte
#structure that will hold the address of the string and the address
#of the next link in the chain.
#$a0 contains a pointer to the string we are adding, and $v0 contains the
#hash of that string.

sw $a0, ($t2)
sll $v0, $v0, 2
la $v1, pointerTable
addu $v0,$v0,$v1
lw $t0, ($v0)
bnez $t0, SRLBucketOccupied

sw $t2, ($v0)
b stringReadLoop


SRLBucketOccupied: 	#There was already an entry in the hash table at pointerTable($v0)!
lw $t1, 4($t0) 		#Check the address field of the entry in the hash table
bnez $t1, SRLBOMoveDownChain #If there's an address there, keep going ->
sw $t2, 4($t0) 		#Otherwise, put the new entry into the address field of the current entry.
b stringReadLoop 	#Done -->
SRLBOMoveDownChain:
move $t0, $t1 		#Make the entry in the address field the current entry.
b SRLBucketOccupied 	#Its address field will be checked, etc. ->

SRLDone:
li $a0, '\n'
li $v0, 11
syscall
jr $t5
#################################################################################
#################################################################################


######################
# CheckInHashTable: is string in hash table?
# $a0: string
# $v0: 0 if string is in hash table, 1 otherwise
#####################
CheckInHashTable:
move $t7, $ra
jal HashFunc
move $ra, $t7
sll $v0, $v0, 2
lw $t0, pointerTable($v0)
beqz $t0, CIHTFail #no entry in the pointer table for hash($a0): a0 is not in table ->
CIHTLoop:
lw $a1, ($t0)
move $t7, $ra
move $t6, $t0
jal StringCmp
move $t0, $t6
move $ra, $t7
beqz $v0, CIHTSuccess
lw $t1, 4($t0)
beqz $t1, CIHTFail
move $t0, $t1
b CIHTLoop
CIHTSuccess:
li $v0, 0
jr $ra
CIHTFail:
li $v0, 1
jr $ra

####################################################
# HashFunc: given 9-character string, produces
# a value corresponding to that string
# between 0 and 1023.
# Arguments:
#	$a0:	pointer to string (ASCII, exactly 9 characters)
# Uses registers:
#	$t0-$t3, $v0
# Returns:
#	$v0: hash
#################################################### 
HashFunc:
li $v0, 0
li $t2, 0
li $t3, 9
move $t0, $a0
HFloop:
addi $t2, $t2, 1
lb $t1, ($t0)
subi $t3, $t3, 1
beqz $t3, HFend
subu $t1, $t1, 96 #converts ASCII char to 0 = '`', 1 = 'a', ...
mulu $t1, $t1, $t2
addu $v0, $v0, $t1
addi $t0, $t0, 1
j HFloop
HFend:
li $t2, 1024
divu $v0, $t2
mfhi $v0
jr $ra 
